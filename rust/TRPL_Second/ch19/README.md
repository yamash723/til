Advanced Features
=======================

これまでで99%くらいは学習完了。残り1%をここと次のCh20でやる

生ポインタ
------------

```rust
let mut num = 5;
let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

* `*const T`/`*mut T`で生ポインタを取得することができる
* 束縛した変数を使用する際は`unsafe`ブロック内で使用しなければならない
* というよりそもそも生ポインタの利点が良く分かってないのが問題

unsage関数/メソッド
--------------------

* `unsafe`をつけることでunsafeな関数、メソッド、トレイトを定義できる
* unsafeな関数、メソッドはunsafeブロック内でしかコールできないことに注意

### 例

* 通常同一変数のmutableな多重参照は不可能
  * 1スライスをmutableな2スライスに分割する場合コンパイラに怒られる
    * `(&mut v[..3], &mut v[3..])`
  * ただこの分割が何も問題ないと理解しているので生ポインタを使用して直接分割する方法をとれる
    * `as_mut_ptr`で変更可能なメモリ領域を取得することができる
    * そこから得たメモリ領域から分割したい範囲を`slice::from_raw_parts_mut`を使用してスライス化
    * こういったやり方が可能

FFI
-------------

* 他言語のライブラリをrustで使用する(Foreign Function interface)場合、`extern`キーワードを使用する
* 同様に他言語から呼び出す関数を作成するときも`extern`使用する
  * この際`[no_mangle]`アノテーションを付与すること
    * コンパイル時に関数名の最適化を行わないようにするため

静的変数へのアクセス
--------------------

* `const`で定数、`static`で静的変数を宣言可能
  * `unsafe`を使用することで静的変数は書き換え可能となる

ライフタイムのサブタイピング
---------------------------

* `<'c, 's: 'c>`のような書き方をする事で`'s`は`'c`以上の寿命を持っているという記述ができる
* スライスを内包する構造体のパーサーがあるとき、「スライスはパーサーよりも長生き」でなければならない
  * とりあえず頭の中に入れておこう

関連型
---------------------------

* トレイトに紐づく型パラメータ
  * トレイト内で`type Node`等で宣言
  * 実装時に`type Node = i32`で型を指定
* 型のデフォルトの指定(演算子オーバーロードの例)
  * `trait Add<RHS=Self>`のように型のデフォルトを指定可能
  * `impl Add for Xxxx`の場合は右辺の型がSelf(Xxxx)の場合の実装になる
  * `impl Add<Yyyy> for Xxxx`の場合は右辺の型がYyyyの場合の実装になる

曖昧さ回避のための完全修飾子
------------------------------

* Rustは同名メソッドを持つ複数のトレイトの実装を回避できない
* 同一メソッドが定義されている場合インスタンスからメソッドを直接呼び出す事はできない
  * ただし直接的な実装(トレイトではなく対象構造体に直接定義されたメソッド)があればそちらを呼ぶことはできる
* 呼び出す場合はトレイト名からの完全修飾子で呼ぶ`Pilot::fly(&person)`
  * 引数である`&self`を満たしてやればよい
* 関数の場合、インスタンス自身を引き渡すことができないので`Trait::function()`といった呼び出し方はできない
  * `Struct as Trait::function()`として呼び出す

トレイトの継承
--------------------------------

* トレイトの実装の際、別のトレイトの実装が必要になったら`trait A : B { }`とすることでBの実装を使用することができる
  * この場合、このトレイトAの実装先はトレイトBも実装しなければならないという縛りが出ている

ニュータイプパターン
--------------------------------

* `Vec<String>`や`Rc<String>`等にはトレイトを直接実装できない
* その場合はニュータイプパターンと呼ばれるものを使用する
  * `struct Wrapper(Vec<String>);`のように別の型を定義。これを使用して`self.0`の内容を操作するもの
    * ドメイン駆動的には値オブジェクトのようなもの？
    * 必要なトレイトは自分で実装していく形になる

型について
-------------------------------

* `type X = Y`の記述で型にエイリアスを設定することが可能
  * これはただのエイリアスなので型チェックなどの利点はない
  * 有効活用するのは冗長な型表記を簡略化するときなど
    * `type Thunk = Box<Fn() + Send + 'static>`といった具合
* NeverTypeと呼ばれるものがある
  * `fn bar() -> ! { panic!(""); }`
  * 絶対に実行が帰ってこない、値が作られないことを示している
  * NeverTypeはあらゆる型へと暗黙に型強制することができる