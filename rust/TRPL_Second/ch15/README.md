スマートポインタの話
===================

> スマートポインタ

※C++とかの話。Rustのようにスコープ外れたりしたら自動で開放？違いは？要勉強

Rustにおけるスマートポインタは三種類

* `Box<T>`
  * ヒープに値を割り当てる
* `Rc<T>`
  * 複数の所有権を許可する
* `Ref<T>` / `RefMut<T>`
  * `RefCell<T>`を使ってアクセス。詳細は後で

`Box<T>`
----------------------

* `let b = Box::new(5)` で任意の値を使用することができる
  * この時newに渡された値はヒープに保存される
  * そのヒープにある値のポインタを値として持ったBoxがスタックに格納される
  * スコープが外れた時はスタックのBox、ヒープの値両方が解放される
  * とはいえ`i32`はそもそもプリミティブでスタック行くので意味はない
* Rustはコンパイル時に型のサイズを知っていなければならない
  * ただ再帰型のような無限に続く可能性のあるものはサイズがわからない
  * そういうものは`Box<T>`で包んであげるとよい(Box自体はサイズがわかっている)

### 再帰の例

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

Consタプル内に同じListが定義されている。`Cons(i32, Box<List>),`と変えればよい

`Deref`
-------------------

* `Deref`はトレイト
* 実装することで参照外しの動作を実装することができる
  * `let y = *x;`のようにアスタリスクで参照外しをすることができる
  * このアスタリスクによる参照外しは`*(y.deref())`と同じ

下記のような書き方が可能

```rust
fn main {
    let name = MyBox::new(String::from("Rust"));
    hello(&name);
}

fn hello(name: &str) {
    println!("Hello {}", name);
}
```

`MyBox` `String`共に`deref`を実装しているので、

* `&MyBox<String>`を`&String`に変換
* `&String`を`&str`に変換

となる。なぜ変換するのかは要調査