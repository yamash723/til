Advanced Features
=======================

これまでで99%くらいは学習完了。残り1%をここと次のCh20でやる

生ポインタ
------------

```rust
let mut num = 5;
let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

* `*const T`/`*mut T`で生ポインタを取得することができる
* 束縛した変数を使用する際は`unsafe`ブロック内で使用しなければならない
* というよりそもそも生ポインタの利点が良く分かってないのが問題

unsage関数/メソッド
--------------------

* `unsafe`をつけることでunsafeな関数、メソッド、トレイトを定義できる
* unsafeな関数、メソッドはunsafeブロック内でしかコールできないことに注意

### 例

* 通常同一変数のmutableな多重参照は不可能
  * 1スライスをmutableな2スライスに分割する場合コンパイラに怒られる
    * `(&mut v[..3], &mut v[3..])`
  * ただこの分割が何も問題ないと理解しているので生ポインタを使用して直接分割する方法をとれる
    * `as_mut_ptr`で変更可能なメモリ領域を取得することができる
    * そこから得たメモリ領域から分割したい範囲を`slice::from_raw_parts_mut`を使用してスライス化
    * こういったやり方が可能

FFI
-------------

* 他言語のライブラリをrustで使用する(Foreign Function interface)場合、`extern`キーワードを使用する
* 同様に他言語から呼び出す関数を作成するときも`extern`使用する
  * この際`[no_mangle]`アノテーションを付与すること
    * コンパイル時に関数名の最適化を行わないようにするため

静的変数へのアクセス
--------------------

* `const`で定数、`static`で静的変数を宣言可能
  * `unsafe`を使用することで静的変数は書き換え可能となる

ライフタイムのサブタイピング
---------------------------

* `<'c, 's: 'c>`のような書き方をする事で`'s`は`'c`以上の寿命を持っているという記述ができる
* スライスを内包する構造体のパーサーがあるとき、「スライスはパーサーよりも長生き」でなければならない
  * とりあえず頭の中に入れておこう

関連型
---------------------------

* トレイトに紐づく型パラメータ
  * トレイト内で`type Node`等で宣言
  * 実装時に`type Node = i32`で型を指定
* 型のデフォルトの指定(演算子オーバーロードの例)
  * `trait Add<RHS=Self>`のように型のデフォルトを指定可能
  * `impl Add for Xxxx`の場合は右辺の型がSelf(Xxxx)の場合の実装になる
  * `impl Add<Yyyy> for Xxxx`の場合は右辺の型がYyyyの場合の実装になる

曖昧さ回避のための完全修飾子
------------------------------

* Rustは同名メソッドを持つ複数のトレイトの実装を回避できない
* 同一メソッドが定義されている場合インスタンスからメソッドを直接呼び出す事はできない
  * ただし直接的な実装(トレイトではなく対象構造体に直接定義されたメソッド)があればそちらを呼ぶことはできる
* 呼び出す場合はトレイト名からの完全修飾子で呼ぶ`Pilot::fly(&person)`
  * 引数である`&self`を満たしてやればよい
* 関数の場合、インスタンス自身を引き渡すことができないので`Trait::function()`といった呼び出し方はできない
  * `Struct as Trait::function()`として呼び出す